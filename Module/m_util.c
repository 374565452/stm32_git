/*
*********************************************************************************************************
*
*	模块名称 : M_UTIL模块
*	文件名称 : m_util.c
* 版    本 ：v1.0
*	说    明 : 常用的工具类函数定义在此文件中进行统一处理
			1.无符号校验和计算函数
			
*			2.	实现printf和scanf函数重定向到通用异步收发器中，即支持printf信息到USART1（例如异步收发器选择USART1）
*				实现重定向，只需要添加2个函数:
*				int fputc(int ch, FILE *f);
*				int fgetc(FILE *f);
*				对于KEIL MDK编译器，编译选项中需要在MicorLib前面打钩，否则不会有数据打印到USART1。
				具体操作如下：
						在工程的属性中，"Target" -> "Code Generation"  选项中勾选"Use MicroLIB"
						MicroLIB是缺省C的备份库，
*
*	修改记录 :
*		版本号  日期        作者     说明
*		V1.0    2016-12-1           正式发布
*   V1.1    2016-12-7           bug修改，将fputc fgetc两个函数中的USART1全部转成DEBUG_UART，至此printf也可以正常使用
*                               增加系统软件复位代码
*
*********************************************************************************************************
*/
#include "m_util.h"
/*
*********************************************************************************************************
*	函 数 名: m_system_reset
*	功能说明: 使软件进行软件复位操作
*	形    参: 
						
*	返 回 值: 无
* 
*
*********************************************************************************************************
*/
__asm void m_system_reset(void)
{
 MOV R0, #1           //; 
 MSR FAULTMASK, R0    //; 清除FAULTMASK  禁止一切中断产生
 LDR R0, =0xE000ED0C  //;
 LDR R1, =0x05FA0004  //; 
 STR R1, [R0]         //; 系统软件复位  
 
deadloop
    B deadloop        //; 死循环程序运行不到下面的代码
}
 

/*
*********************************************************************************************************
*	函 数 名: m_check_unsigned_sum
*	功能说明: 计算无符号校验和，根据指定的缓冲区的数据计算其8位无符号校验和
*	形    参: uint8_t * buffer,需要进行校验的数据
						uint32_t len ,数据长度
*	返 回 值: 经过计算得到的无符号校验和数据
* 
* 注：此函数问题：之前在用到数源扩展板时，由于当前将数据长度变量的类型写成uint8_t导致传入的数据长度
*			如果大于255，计算出来的数据校验和不正确。此处的数据长度类型应该为uint32_t
*     校验和算法为：将所有的数据累计相加，得到的和只取低8位
*
*********************************************************************************************************
*/
uint8_t m_check_unsigned_sum(uint8_t * buffer, uint32_t len)
{
	uint32_t i = 0 ;
	uint8_t sumchek=0;
	for(i = 0 ;i<len;i++)
	{
		sumchek += buffer[i];
	}
	return sumchek;
}

/*
*********************************************************************************************************
*	函 数 名: fputc
*	功能说明: 重定义putc函数，这样可以使用printf函数从指定的串口中打印输出
*	形    参: 无
*	返 回 值: 无
*********************************************************************************************************
*/
#if M_PRINTF_EN ==1
int fputc(int ch, FILE *f)
{
	
	/* 写一个字节到USART1 */
	USART_SendData(DEBUG_UART, (uint8_t) ch);

	/* 等待发送结束 */
	while (USART_GetFlagStatus(DEBUG_UART, USART_FLAG_TC) == RESET)
	{}

	return ch;
	
}
#endif
/*
*********************************************************************************************************
*	函 数 名: fgetc
*	功能说明: 重定义getc函数，这样可以使用scanff函数从指定的串口中输入数据
*	形    参: 无
*	返 回 值: 无
*********************************************************************************************************
*/
#if M_PRINTF_EN ==1
int fgetc(FILE *f)
{
	/* 等待串口1输入数据 */
	while (USART_GetFlagStatus(DEBUG_UART, USART_FLAG_RXNE) == RESET);

	return (int)USART_ReceiveData(DEBUG_UART);
}
#endif